import{e as be,w as I,V as Pt,z as rn,L as Y,H as q,J as fs,K as et,N as nt,Q as ps,X as ds,c as on,Y as pn,Z as Zn,_ as Bt,a as je,$ as hs,G as ys,T as ms,U as K,C as vt,B as dn,n as hn,P as yn,h as gs,i as xs,g as ws,D as As,u as bs,j as Ts,k as Ss,E as Ps,l as Bs,O as _s,b as vs}from"./GLTFLoader-Cpm_xSlR.js";import{R as Ms,z as mn}from"./three-custom-shader-material.es-BKijawVj.js";import{d as Cs,f as Is,p as Es,k as zs,w as Ls,q as Ns,o as Rs,h as gn}from"./index-qyBmO-yZ.js";import{a as Fs}from"./_plugin-vue_export-helper-CQ7wvoWd.js";const Kn=0,Ds=1,Us=2,xn=2,Pe=1.25,wn=1,Ht=6*4+4+4,Te=65535,ks=Math.pow(2,-24),Be=Symbol("SKIP_GENERATION");function Vs(n){return n.index?n.index.count:n.attributes.position.count}function Ft(n){return Vs(n)/3}function qs(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function $s(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=qs(e,s);n.setIndex(new be(i,1));for(let r=0;r<e;r++)i[r]=r}}function Jn(n,t){const e=Ft(n),s=t||n.drawRange,i=s.start/3,r=(s.start+s.count)/3,a=Math.max(0,i),c=Math.min(e,r)-a;return[{offset:Math.floor(a),count:Math.floor(c)}]}function Qn(n,t){if(!n.groups||!n.groups.length)return Jn(n,t);const e=[],s=new Set,i=t||n.drawRange,r=i.start/3,a=(i.start+i.count)/3;for(const o of n.groups){const f=o.start/3,l=(o.start+o.count)/3;s.add(Math.max(r,f)),s.add(Math.min(a,l))}const c=Array.from(s.values()).sort((o,f)=>o-f);for(let o=0;o<c.length-1;o++){const f=c[o],l=c[o+1];e.push({offset:Math.floor(f),count:Math.floor(l-f)})}return e}function Gs(n,t){const e=Ft(n),s=Qn(n,t).sort((a,c)=>a.offset-c.offset),i=s[s.length-1];i.count=Math.min(e-i.offset,i.count);let r=0;return s.forEach(({count:a})=>r+=a),e!==r}function _e(n,t,e,s,i){let r=1/0,a=1/0,c=1/0,o=-1/0,f=-1/0,l=-1/0,p=1/0,u=1/0,d=1/0,w=-1/0,b=-1/0,x=-1/0;for(let h=t*6,y=(t+e)*6;h<y;h+=6){const g=n[h+0],A=n[h+1],m=g-A,T=g+A;m<r&&(r=m),T>o&&(o=T),g<p&&(p=g),g>w&&(w=g);const S=n[h+2],P=n[h+3],B=S-P,v=S+P;B<a&&(a=B),v>f&&(f=v),S<u&&(u=S),S>b&&(b=S);const C=n[h+4],_=n[h+5],M=C-_,E=C+_;M<c&&(c=M),E>l&&(l=E),C<d&&(d=C),C>x&&(x=C)}s[0]=r,s[1]=a,s[2]=c,s[3]=o,s[4]=f,s[5]=l,i[0]=p,i[1]=u,i[2]=d,i[3]=w,i[4]=b,i[5]=x}function Ws(n,t=null,e=null,s=null){const i=n.attributes.position,r=n.index?n.index.array:null,a=Ft(n),c=i.normalized;let o;t===null?(o=new Float32Array(a*6),e=0,s=a):(o=t,e=e||0,s=s||a);const f=i.array,l=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const u=["getX","getY","getZ"];for(let d=e;d<e+s;d++){const w=d*3,b=d*6;let x=w+0,h=w+1,y=w+2;r&&(x=r[x],h=r[h],y=r[y]),c||(x=x*p+l,h=h*p+l,y=y*p+l);for(let g=0;g<3;g++){let A,m,T;c?(A=i[u[g]](x),m=i[u[g]](h),T=i[u[g]](y)):(A=f[x+g],m=f[h+g],T=f[y+g]);let S=A;m<S&&(S=m),T<S&&(S=T);let P=A;m>P&&(P=m),T>P&&(P=T);const B=(P-S)/2,v=g*2;o[b+v+0]=S+B,o[b+v+1]=B+(Math.abs(S)+B)*ks}}return o}function R(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function An(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function bn(n,t){t.set(n)}function Tn(n,t,e){let s,i;for(let r=0;r<3;r++){const a=r+3;s=n[r],i=t[r],e[r]=s<i?s:i,s=n[a],i=t[a],e[a]=s>i?s:i}}function Yt(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],r=t[n+2*s+1],a=i-r,c=i+r;a<e[s]&&(e[s]=a),c>e[s+3]&&(e[s+3]=c)}}function Dt(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const ot=32,Os=(n,t)=>n.candidate-t.candidate,at=new Array(ot).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Zt=new Float32Array(6);function Hs(n,t,e,s,i,r){let a=-1,c=0;if(r===Kn)a=An(t),a!==-1&&(c=(t[a]+t[a+3])/2);else if(r===Ds)a=An(n),a!==-1&&(c=Xs(e,s,i,a));else if(r===Us){const o=Dt(n);let f=Pe*i;const l=s*6,p=(s+i)*6;for(let u=0;u<3;u++){const d=t[u],x=(t[u+3]-d)/ot;if(i<ot/4){const h=[...at];h.length=i;let y=0;for(let A=l;A<p;A+=6,y++){const m=h[y];m.candidate=e[A+2*u],m.count=0;const{bounds:T,leftCacheBounds:S,rightCacheBounds:P}=m;for(let B=0;B<3;B++)P[B]=1/0,P[B+3]=-1/0,S[B]=1/0,S[B+3]=-1/0,T[B]=1/0,T[B+3]=-1/0;Yt(A,e,T)}h.sort(Os);let g=i;for(let A=0;A<g;A++){const m=h[A];for(;A+1<g&&h[A+1].candidate===m.candidate;)h.splice(A+1,1),g--}for(let A=l;A<p;A+=6){const m=e[A+2*u];for(let T=0;T<g;T++){const S=h[T];m>=S.candidate?Yt(A,e,S.rightCacheBounds):(Yt(A,e,S.leftCacheBounds),S.count++)}}for(let A=0;A<g;A++){const m=h[A],T=m.count,S=i-m.count,P=m.leftCacheBounds,B=m.rightCacheBounds;let v=0;T!==0&&(v=Dt(P)/o);let C=0;S!==0&&(C=Dt(B)/o);const _=wn+Pe*(v*T+C*S);_<f&&(a=u,f=_,c=m.candidate)}}else{for(let g=0;g<ot;g++){const A=at[g];A.count=0,A.candidate=d+x+g*x;const m=A.bounds;for(let T=0;T<3;T++)m[T]=1/0,m[T+3]=-1/0}for(let g=l;g<p;g+=6){let T=~~((e[g+2*u]-d)/x);T>=ot&&(T=ot-1);const S=at[T];S.count++,Yt(g,e,S.bounds)}const h=at[ot-1];bn(h.bounds,h.rightCacheBounds);for(let g=ot-2;g>=0;g--){const A=at[g],m=at[g+1];Tn(A.bounds,m.rightCacheBounds,A.rightCacheBounds)}let y=0;for(let g=0;g<ot-1;g++){const A=at[g],m=A.count,T=A.bounds,P=at[g+1].rightCacheBounds;m!==0&&(y===0?bn(T,Zt):Tn(T,Zt,Zt)),y+=m;let B=0,v=0;y!==0&&(B=Dt(Zt)/o);const C=i-y;C!==0&&(v=Dt(P)/o);const _=wn+Pe*(B*y+v*C);_<f&&(a=u,f=_,c=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:a,pos:c}}function Xs(n,t,e,s){let i=0;for(let r=t,a=t+e;r<a;r++)i+=n[r*6+s*2];return i/e}class ve{constructor(){this.boundingData=new Float32Array(6)}}function js(n,t,e,s,i,r){let a=s,c=s+i-1;const o=r.pos,f=r.axis*2;for(;;){for(;a<=c&&e[a*6+f]<o;)a++;for(;a<=c&&e[c*6+f]>=o;)c--;if(a<c){for(let l=0;l<3;l++){let p=t[a*3+l];t[a*3+l]=t[c*3+l],t[c*3+l]=p}for(let l=0;l<6;l++){let p=e[a*6+l];e[a*6+l]=e[c*6+l],e[c*6+l]=p}a++,c--}else return a}}function Ys(n,t,e,s,i,r){let a=s,c=s+i-1;const o=r.pos,f=r.axis*2;for(;;){for(;a<=c&&e[a*6+f]<o;)a++;for(;a<=c&&e[c*6+f]>=o;)c--;if(a<c){let l=n[a];n[a]=n[c],n[c]=l;for(let p=0;p<6;p++){let u=e[a*6+p];e[a*6+p]=e[c*6+p],e[c*6+p]=u}a++,c--}else return a}}function $(n,t){return t[n+15]===65535}function G(n,t){return t[n+6]}function O(n,t){return t[n+14]}function H(n){return n+8}function X(n,t){return t[n+6]}function ts(n,t){return t[n+7]}let es,Ot,he,ns;const Zs=Math.pow(2,32);function Ye(n){return"count"in n?1:1+Ye(n.left)+Ye(n.right)}function Ks(n,t,e){return es=new Float32Array(e),Ot=new Uint32Array(e),he=new Uint16Array(e),ns=new Uint8Array(e),Ze(n,t)}function Ze(n,t){const e=n/4,s=n/2,i="count"in t,r=t.boundingData;for(let a=0;a<6;a++)es[e+a]=r[a];if(i)if(t.buffer){const a=t.buffer;ns.set(new Uint8Array(a),n);for(let c=n,o=n+a.byteLength;c<o;c+=Ht){const f=c/2;$(f,he)||(Ot[c/4+6]+=e)}return n+a.byteLength}else{const a=t.offset,c=t.count;return Ot[e+6]=a,he[s+14]=c,he[s+15]=Te,n+Ht}else{const a=t.left,c=t.right,o=t.splitAxis;let f;if(f=Ze(n+Ht,a),f/4>Zs)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ot[e+6]=f/4,f=Ze(f,c),Ot[e+7]=o,f}}function Js(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,r=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),a=s?new Uint32Array(r):new Uint16Array(r);for(let c=0,o=a.length;c<o;c++)a[c]=c;return a}function Qs(n,t,e,s,i){const{maxDepth:r,verbose:a,maxLeafTris:c,strategy:o,onProgress:f,indirect:l}=i,p=n._indirectBuffer,u=n.geometry,d=u.index?u.index.array:null,w=l?Ys:js,b=Ft(u),x=new Float32Array(6);let h=!1;const y=new ve;return _e(t,e,s,y.boundingData,x),A(y,e,s,x),y;function g(m){f&&f(m/b)}function A(m,T,S,P=null,B=0){if(!h&&B>=r&&(h=!0,a&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),S<=c||B>=r)return g(T+S),m.offset=T,m.count=S,m;const v=Hs(m.boundingData,P,t,T,S,o);if(v.axis===-1)return g(T+S),m.offset=T,m.count=S,m;const C=w(p,d,t,T,S,v);if(C===T||C===T+S)g(T+S),m.offset=T,m.count=S;else{m.splitAxis=v.axis;const _=new ve,M=T,E=C-T;m.left=_,_e(t,M,E,_.boundingData,x),A(_,M,E,x,B+1);const z=new ve,L=C,U=S-E;m.right=z,_e(t,L,U,z.boundingData,x),A(z,L,U,x,B+1)}return m}}function ti(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=Js(e,t.useSharedArrayBuffer),Gs(e,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||$s(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ws(e),r=t.indirect?Jn(e,t.range):Qn(e,t.range);n._roots=r.map(a=>{const c=Qs(n,i,a.offset,a.count,t),o=Ye(c),f=new s(Ht*o);return Ks(0,c,f),f})}class ct{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,a=t.length;r<a;r++){const o=t[r][e];s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,a=e.length;r<a;r++){const c=e[r],o=t.dot(c);s=o<s?o:s,i=o>i?o:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ct.prototype.setFromBox=function(){const n=new I;return function(e,s){const i=s.min,r=s.max;let a=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){n.x=i.x*o+r.x*(1-o),n.y=i.y*f+r.y*(1-f),n.z=i.z*l+r.z*(1-l);const p=e.dot(n);a=Math.min(p,a),c=Math.max(p,c)}this.min=a,this.max=c}}();const ei=function(){const n=new I,t=new I,e=new I;return function(i,r,a){const c=i.start,o=n,f=r.start,l=t;e.subVectors(c,f),n.subVectors(i.end,i.start),t.subVectors(r.end,r.start);const p=e.dot(l),u=l.dot(o),d=l.dot(l),w=e.dot(o),x=o.dot(o)*d-u*u;let h,y;x!==0?h=(p*u-w*d)/x:h=0,y=(p+h*u)/d,a.x=h,a.y=y}}(),cn=function(){const n=new Pt,t=new I,e=new I;return function(i,r,a,c){ei(i,r,n);let o=n.x,f=n.y;if(o>=0&&o<=1&&f>=0&&f<=1){i.at(o,a),r.at(f,c);return}else if(o>=0&&o<=1){f<0?r.at(0,c):r.at(1,c),i.closestPointToPoint(c,!0,a);return}else if(f>=0&&f<=1){o<0?i.at(0,a):i.at(1,a),r.closestPointToPoint(a,!0,c);return}else{let l;o<0?l=i.start:l=i.end;let p;f<0?p=r.start:p=r.end;const u=t,d=e;if(i.closestPointToPoint(p,!0,t),r.closestPointToPoint(l,!0,e),u.distanceToSquared(p)<=d.distanceToSquared(l)){a.copy(u),c.copy(p);return}else{a.copy(l),c.copy(d);return}}}}(),ni=function(){const n=new I,t=new I,e=new rn,s=new Y;return function(r,a){const{radius:c,center:o}=r,{a:f,b:l,c:p}=a;if(s.start=f,s.end=l,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c||(s.start=f,s.end=p,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c)||(s.start=l,s.end=p,s.closestPointToPoint(o,!0,n).distanceTo(o)<=c))return!0;const b=a.getPlane(e);if(Math.abs(b.distanceToPoint(o))<=c){const h=b.projectPoint(o,t);if(a.containsPoint(h))return!0}return!1}}(),si=1e-15;function Me(n){return Math.abs(n)<si}class Z extends q{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new I),this.satBounds=new Array(4).fill().map(()=>new ct),this.points=[this.a,this.b,this.c],this.sphere=new fs,this.plane=new rn,this.needsUpdate=!0}intersectsSphere(t){return ni(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,a=this.satBounds,c=r[0],o=a[0];this.getNormal(c),o.setFromPoints(c,i);const f=r[1],l=a[1];f.subVectors(t,e),l.setFromPoints(f,i);const p=r[2],u=a[2];p.subVectors(e,s),u.setFromPoints(p,i);const d=r[3],w=a[3];d.subVectors(s,t),w.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}Z.prototype.closestPointToSegment=function(){const n=new I,t=new I,e=new Y;return function(i,r=null,a=null){const{start:c,end:o}=i,f=this.points;let l,p=1/0;for(let u=0;u<3;u++){const d=(u+1)%3;e.start.copy(f[u]),e.end.copy(f[d]),cn(e,i,n,t),l=n.distanceToSquared(t),l<p&&(p=l,r&&r.copy(n),a&&a.copy(t))}return this.closestPointToPoint(c,n),l=c.distanceToSquared(n),l<p&&(p=l,r&&r.copy(n),a&&a.copy(c)),this.closestPointToPoint(o,n),l=o.distanceToSquared(n),l<p&&(p=l,r&&r.copy(n),a&&a.copy(o)),Math.sqrt(p)}}();Z.prototype.intersectsTriangle=function(){const n=new Z,t=new Array(3),e=new Array(3),s=new ct,i=new ct,r=new I,a=new I,c=new I,o=new I,f=new I,l=new Y,p=new Y,u=new Y,d=new I;function w(b,x,h){const y=b.points;let g=0,A=-1;for(let m=0;m<3;m++){const{start:T,end:S}=l;T.copy(y[m]),S.copy(y[(m+1)%3]),l.delta(a);const P=Me(x.distanceToPoint(T));if(Me(x.normal.dot(a))&&P){h.copy(l),g=2;break}const B=x.intersectLine(l,d);if(!B&&P&&d.copy(T),(B||P)&&!Me(d.distanceTo(S))){if(g<=1)(g===1?h.start:h.end).copy(d),P&&(A=g);else if(g>=2){(A===1?h.start:h.end).copy(d),g=2;break}if(g++,g===2&&A===-1)break}}return g}return function(x,h=null,y=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(n.copy(x),n.update(),x=n);const g=this.plane,A=x.plane;if(Math.abs(g.normal.dot(A.normal))>1-1e-10){const m=this.satBounds,T=this.satAxes;e[0]=x.a,e[1]=x.b,e[2]=x.c;for(let B=0;B<4;B++){const v=m[B],C=T[B];if(s.setFromPoints(C,e),v.isSeparated(s))return!1}const S=x.satBounds,P=x.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let B=0;B<4;B++){const v=S[B],C=P[B];if(s.setFromPoints(C,t),v.isSeparated(s))return!1}for(let B=0;B<4;B++){const v=T[B];for(let C=0;C<4;C++){const _=P[C];if(r.crossVectors(v,_),s.setFromPoints(r,t),i.setFromPoints(r,e),s.isSeparated(i))return!1}}return h&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}else{const m=w(this,A,p);if(m===1&&x.containsPoint(p.end))return h&&(h.start.copy(p.end),h.end.copy(p.end)),!0;if(m!==2)return!1;const T=w(x,g,u);if(T===1&&this.containsPoint(u.end))return h&&(h.start.copy(u.end),h.end.copy(u.end)),!0;if(T!==2)return!1;if(p.delta(c),u.delta(o),c.dot(o)<0){let M=u.start;u.start=u.end,u.end=M}const S=p.start.dot(c),P=p.end.dot(c),B=u.start.dot(c),v=u.end.dot(c),C=P<B,_=S<v;return S!==v&&B!==P&&C===_?!1:(h&&(f.subVectors(p.start,u.start),f.dot(c)>0?h.start.copy(p.start):h.start.copy(u.start),f.subVectors(p.end,u.end),f.dot(c)<0?h.end.copy(p.end):h.end.copy(u.end)),!0)}}}();Z.prototype.distanceToPoint=function(){const n=new I;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();Z.prototype.distanceToTriangle=function(){const n=new I,t=new I,e=["a","b","c"],s=new Y,i=new Y;return function(a,c=null,o=null){const f=c||o?s:null;if(this.intersectsTriangle(a,f))return(c||o)&&(c&&f.getCenter(c),o&&f.getCenter(o)),0;let l=1/0;for(let p=0;p<3;p++){let u;const d=e[p],w=a[d];this.closestPointToPoint(w,n),u=w.distanceToSquared(n),u<l&&(l=u,c&&c.copy(n),o&&o.copy(w));const b=this[d];a.closestPointToPoint(b,n),u=b.distanceToSquared(n),u<l&&(l=u,c&&c.copy(b),o&&o.copy(n))}for(let p=0;p<3;p++){const u=e[p],d=e[(p+1)%3];s.set(this[u],this[d]);for(let w=0;w<3;w++){const b=e[w],x=e[(w+1)%3];i.set(a[b],a[x]),cn(s,i,n,t);const h=n.distanceToSquared(t);h<l&&(l=h,c&&c.copy(n),o&&o.copy(t))}}return Math.sqrt(l)}}();class V{constructor(t,e,s){this.isOrientedBox=!0,this.min=new I,this.max=new I,this.matrix=new et,this.invMatrix=new et,this.points=new Array(8).fill().map(()=>new I),this.satAxes=new Array(3).fill().map(()=>new I),this.satBounds=new Array(3).fill().map(()=>new ct),this.alignedSatBounds=new Array(3).fill().map(()=>new ct),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const u=1*f|2*l|4*p,d=i[u];d.x=f?s.x:e.x,d.y=l?s.y:e.y,d.z=p?s.z:e.z,d.applyMatrix4(t)}const r=this.satBounds,a=this.satAxes,c=i[0];for(let f=0;f<3;f++){const l=a[f],p=r[f],u=1<<f,d=i[u];l.subVectors(c,d),p.setFromPoints(l,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const n=new ct;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,a=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let o=0;o<3;o++){const f=a[o],l=r[o];if(n.setFromBox(f,e),l.isSeparated(n))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const n=new Z,t=new Array(3),e=new ct,s=new ct,i=new I;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(n.copy(a),n.update(),a=n);const c=this.satBounds,o=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let u=0;u<3;u++){const d=c[u],w=o[u];if(e.setFromPoints(w,t),d.isSeparated(e))return!1}const f=a.satBounds,l=a.satAxes,p=this.points;for(let u=0;u<3;u++){const d=f[u],w=l[u];if(e.setFromPoints(w,p),d.isSeparated(e))return!1}for(let u=0;u<3;u++){const d=o[u];for(let w=0;w<4;w++){const b=l[w];if(i.crossVectors(d,b),e.setFromPoints(i,t),s.setFromPoints(i,p),e.isSeparated(s))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();V.prototype.distanceToPoint=function(){const n=new I;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();V.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new Y),e=new Array(12).fill().map(()=>new Y),s=new I,i=new I;return function(a,c=0,o=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(o||f)&&(a.getCenter(i),this.closestPointToPoint(i,s),a.closestPointToPoint(s,i),o&&o.copy(s),f&&f.copy(i)),0;const l=c*c,p=a.min,u=a.max,d=this.points;let w=1/0;for(let x=0;x<8;x++){const h=d[x];i.copy(h).clamp(p,u);const y=h.distanceToSquared(i);if(y<w&&(w=y,o&&o.copy(h),f&&f.copy(i),y<l))return Math.sqrt(y)}let b=0;for(let x=0;x<3;x++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){const g=(x+1)%3,A=(x+2)%3,m=h<<g|y<<A,T=1<<x|h<<g|y<<A,S=d[m],P=d[T];t[b].set(S,P);const v=n[x],C=n[g],_=n[A],M=e[b],E=M.start,z=M.end;E[v]=p[v],E[C]=h?p[C]:u[C],E[_]=y?p[_]:u[C],z[v]=u[v],z[C]=h?p[C]:u[C],z[_]=y?p[_]:u[C],b++}for(let x=0;x<=1;x++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){i.x=x?u.x:p.x,i.y=h?u.y:p.y,i.z=y?u.z:p.z,this.closestPointToPoint(i,s);const g=i.distanceToSquared(s);if(g<w&&(w=g,o&&o.copy(s),f&&f.copy(i),g<l))return Math.sqrt(g)}for(let x=0;x<12;x++){const h=t[x];for(let y=0;y<12;y++){const g=e[y];cn(h,g,s,i);const A=s.distanceToSquared(i);if(A<w&&(w=A,o&&o.copy(s),f&&f.copy(i),A<l))return Math.sqrt(A)}}return Math.sqrt(w)}}();class an{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ii extends an{constructor(){super(()=>new Z)}}const j=new ii;class ri{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const N=new ri;let pt,Rt;const Mt=[],Kt=new an(()=>new nt);function oi(n,t,e,s,i,r){pt=Kt.getPrimitive(),Rt=Kt.getPrimitive(),Mt.push(pt,Rt),N.setBuffer(n._roots[t]);const a=Ke(0,n.geometry,e,s,i,r);N.clearBuffer(),Kt.releasePrimitive(pt),Kt.releasePrimitive(Rt),Mt.pop(),Mt.pop();const c=Mt.length;return c>0&&(Rt=Mt[c-1],pt=Mt[c-2]),a}function Ke(n,t,e,s,i=null,r=0,a=0){const{float32Array:c,uint16Array:o,uint32Array:f}=N;let l=n*2;if($(l,o)){const u=G(n,f),d=O(l,o);return R(n,c,pt),s(u,d,!1,a,r+n,pt)}else{let v=function(_){const{uint16Array:M,uint32Array:E}=N;let z=_*2;for(;!$(z,M);)_=H(_),z=_*2;return G(_,E)},C=function(_){const{uint16Array:M,uint32Array:E}=N;let z=_*2;for(;!$(z,M);)_=X(_,E),z=_*2;return G(_,E)+O(z,M)};const u=H(n),d=X(n,f);let w=u,b=d,x,h,y,g;if(i&&(y=pt,g=Rt,R(w,c,y),R(b,c,g),x=i(y),h=i(g),h<x)){w=d,b=u;const _=x;x=h,h=_,y=g}y||(y=pt,R(w,c,y));const A=$(w*2,o),m=e(y,A,x,a+1,r+w);let T;if(m===xn){const _=v(w),E=C(w)-_;T=s(_,E,!0,a+1,r+w,y)}else T=m&&Ke(w,t,e,s,i,r,a+1);if(T)return!0;g=Rt,R(b,c,g);const S=$(b*2,o),P=e(g,S,h,a+1,r+b);let B;if(P===xn){const _=v(b),E=C(b)-_;B=s(_,E,!0,a+1,r+b,g)}else B=P&&Ke(b,t,e,s,i,r,a+1);return!!B}}const Ut=new I,Ce=new I;function ci(n,t,e={},s=0,i=1/0){const r=s*s,a=i*i;let c=1/0,o=null;if(n.shapecast({boundsTraverseOrder:l=>(Ut.copy(t).clamp(l.min,l.max),Ut.distanceToSquared(t)),intersectsBounds:(l,p,u)=>u<c&&u<a,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,Ut);const u=t.distanceToSquared(Ut);return u<c&&(Ce.copy(Ut),c=u,o=p),u<r}}),c===1/0)return null;const f=Math.sqrt(c);return e.point?e.point.copy(Ce):e.point=Ce.clone(),e.distance=f,e.faceIndex=o,e}const ai=parseInt(ps)>=169,mt=new I,gt=new I,xt=new I,Jt=new Pt,Qt=new Pt,te=new Pt,Sn=new I,Pn=new I,Bn=new I,kt=new I;function li(n,t,e,s,i,r,a,c){let o;if(r===ds?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,r!==on,i),o===null)return null;const f=n.origin.distanceTo(i);return f<a||f>c?null:{distance:f,point:i.clone()}}function ui(n,t,e,s,i,r,a,c,o,f,l){mt.fromBufferAttribute(t,r),gt.fromBufferAttribute(t,a),xt.fromBufferAttribute(t,c);const p=li(n,mt,gt,xt,kt,o,f,l);if(p){const u=new I;q.getBarycoord(kt,mt,gt,xt,u),s&&(Jt.fromBufferAttribute(s,r),Qt.fromBufferAttribute(s,a),te.fromBufferAttribute(s,c),p.uv=q.getInterpolation(kt,mt,gt,xt,Jt,Qt,te,new Pt)),i&&(Jt.fromBufferAttribute(i,r),Qt.fromBufferAttribute(i,a),te.fromBufferAttribute(i,c),p.uv1=q.getInterpolation(kt,mt,gt,xt,Jt,Qt,te,new Pt)),e&&(Sn.fromBufferAttribute(e,r),Pn.fromBufferAttribute(e,a),Bn.fromBufferAttribute(e,c),p.normal=q.getInterpolation(kt,mt,gt,xt,Sn,Pn,Bn,new I),p.normal.dot(n.direction)>0&&p.normal.multiplyScalar(-1));const d={a:r,b:a,c,normal:new I,materialIndex:0};q.getNormal(mt,gt,xt,d.normal),p.face=d,p.faceIndex=r,ai&&(p.barycoord=u)}return p}function Se(n,t,e,s,i,r,a){const c=s*3;let o=c+0,f=c+1,l=c+2;const p=n.index;n.index&&(o=p.getX(o),f=p.getX(f),l=p.getX(l));const{position:u,normal:d,uv:w,uv1:b}=n.attributes,x=ui(e,u,d,w,b,o,f,l,t,r,a);return x?(x.faceIndex=s,i&&i.push(x),x):null}function D(n,t,e,s){const i=n.a,r=n.b,a=n.c;let c=t,o=t+1,f=t+2;e&&(c=e.getX(c),o=e.getX(o),f=e.getX(f)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),r.x=s.getX(o),r.y=s.getY(o),r.z=s.getZ(o),a.x=s.getX(f),a.y=s.getY(f),a.z=s.getZ(f)}function fi(n,t,e,s,i,r,a,c){const{geometry:o,_indirectBuffer:f}=n;for(let l=s,p=s+i;l<p;l++)Se(o,t,e,l,r,a,c)}function pi(n,t,e,s,i,r,a){const{geometry:c,_indirectBuffer:o}=n;let f=1/0,l=null;for(let p=s,u=s+i;p<u;p++){let d;d=Se(c,t,e,p,null,r,a),d&&d.distance<f&&(l=d,f=d.distance)}return l}function di(n,t,e,s,i,r,a){const{geometry:c}=e,{index:o}=c,f=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let u;if(u=l,D(a,u*3,o,f),a.needsUpdate=!0,s(a,u,i,r))return!0}return!1}function hi(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let r,a,c,o,f=0;const l=n._roots;for(let u=0,d=l.length;u<d;u++)r=l[u],a=new Uint32Array(r),c=new Uint16Array(r),o=new Float32Array(r),p(0,f),f+=r.byteLength;function p(u,d,w=!1){const b=u*2;if(c[b+15]===Te){const h=a[u+6],y=c[b+14];let g=1/0,A=1/0,m=1/0,T=-1/0,S=-1/0,P=-1/0;for(let B=3*h,v=3*(h+y);B<v;B++){let C=s[B];const _=i.getX(C),M=i.getY(C),E=i.getZ(C);_<g&&(g=_),_>T&&(T=_),M<A&&(A=M),M>S&&(S=M),E<m&&(m=E),E>P&&(P=E)}return o[u+0]!==g||o[u+1]!==A||o[u+2]!==m||o[u+3]!==T||o[u+4]!==S||o[u+5]!==P?(o[u+0]=g,o[u+1]=A,o[u+2]=m,o[u+3]=T,o[u+4]=S,o[u+5]=P,!0):!1}else{const h=u+8,y=a[u+6],g=h+d,A=y+d;let m=w,T=!1,S=!1;t?m||(T=t.has(g),S=t.has(A),m=!T&&!S):(T=!0,S=!0);const P=m||T,B=m||S;let v=!1;P&&(v=p(h,d,m));let C=!1;B&&(C=p(y,d,m));const _=v||C;if(_)for(let M=0;M<3;M++){const E=h+M,z=y+M,L=o[E],U=o[E+3],_t=o[z],yt=o[z+3];o[u+M]=L<_t?L:_t,o[u+M+3]=U>yt?U:yt}return _}}}function ht(n,t,e,s,i){let r,a,c,o,f,l;const p=1/e.direction.x,u=1/e.direction.y,d=1/e.direction.z,w=e.origin.x,b=e.origin.y,x=e.origin.z;let h=t[n],y=t[n+3],g=t[n+1],A=t[n+3+1],m=t[n+2],T=t[n+3+2];return p>=0?(r=(h-w)*p,a=(y-w)*p):(r=(y-w)*p,a=(h-w)*p),u>=0?(c=(g-b)*u,o=(A-b)*u):(c=(A-b)*u,o=(g-b)*u),r>o||c>a||((c>r||isNaN(r))&&(r=c),(o<a||isNaN(a))&&(a=o),d>=0?(f=(m-x)*d,l=(T-x)*d):(f=(T-x)*d,l=(m-x)*d),r>l||f>a)?!1:((f>r||r!==r)&&(r=f),(l<a||a!==a)&&(a=l),r<=i&&a>=s)}function yi(n,t,e,s,i,r,a,c){const{geometry:o,_indirectBuffer:f}=n;for(let l=s,p=s+i;l<p;l++){let u=f?f[l]:l;Se(o,t,e,u,r,a,c)}}function mi(n,t,e,s,i,r,a){const{geometry:c,_indirectBuffer:o}=n;let f=1/0,l=null;for(let p=s,u=s+i;p<u;p++){let d;d=Se(c,t,e,o?o[p]:p,null,r,a),d&&d.distance<f&&(l=d,f=d.distance)}return l}function gi(n,t,e,s,i,r,a){const{geometry:c}=e,{index:o}=c,f=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let u;if(u=e.resolveTriangleIndex(l),D(a,u*3,o,f),a.needsUpdate=!0,s(a,u,i,r))return!0}return!1}function xi(n,t,e,s,i,r,a){N.setBuffer(n._roots[t]),Je(0,n,e,s,i,r,a),N.clearBuffer()}function Je(n,t,e,s,i,r,a){const{float32Array:c,uint16Array:o,uint32Array:f}=N,l=n*2;if($(l,o)){const u=G(n,f),d=O(l,o);fi(t,e,s,u,d,i,r,a)}else{const u=H(n);ht(u,c,s,r,a)&&Je(u,t,e,s,i,r,a);const d=X(n,f);ht(d,c,s,r,a)&&Je(d,t,e,s,i,r,a)}}const wi=["x","y","z"];function Ai(n,t,e,s,i,r){N.setBuffer(n._roots[t]);const a=Qe(0,n,e,s,i,r);return N.clearBuffer(),a}function Qe(n,t,e,s,i,r){const{float32Array:a,uint16Array:c,uint32Array:o}=N;let f=n*2;if($(f,c)){const p=G(n,o),u=O(f,c);return pi(t,e,s,p,u,i,r)}else{const p=ts(n,o),u=wi[p],w=s.direction[u]>=0;let b,x;w?(b=H(n),x=X(n,o)):(b=X(n,o),x=H(n));const y=ht(b,a,s,i,r)?Qe(b,t,e,s,i,r):null;if(y){const m=y.point[u];if(w?m<=a[x+p]:m>=a[x+p+3])return y}const A=ht(x,a,s,i,r)?Qe(x,t,e,s,i,r):null;return y&&A?y.distance<=A.distance?y:A:y||A||null}}const ee=new nt,Ct=new Z,It=new Z,Vt=new et,_n=new V,ne=new V;function bi(n,t,e,s){N.setBuffer(n._roots[t]);const i=tn(0,n,e,s);return N.clearBuffer(),i}function tn(n,t,e,s,i=null){const{float32Array:r,uint16Array:a,uint32Array:c}=N;let o=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),_n.set(e.boundingBox.min,e.boundingBox.max,s),i=_n),$(o,a)){const l=t.geometry,p=l.index,u=l.attributes.position,d=e.index,w=e.attributes.position,b=G(n,c),x=O(o,a);if(Vt.copy(s).invert(),e.boundsTree)return R(n,r,ne),ne.matrix.copy(Vt),ne.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:y=>ne.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let g=b*3,A=(x+b)*3;g<A;g+=3)if(D(It,g,p,u),It.needsUpdate=!0,y.intersectsTriangle(It))return!0;return!1}});for(let h=b*3,y=(x+b)*3;h<y;h+=3){D(Ct,h,p,u),Ct.a.applyMatrix4(Vt),Ct.b.applyMatrix4(Vt),Ct.c.applyMatrix4(Vt),Ct.needsUpdate=!0;for(let g=0,A=d.count;g<A;g+=3)if(D(It,g,d,w),It.needsUpdate=!0,Ct.intersectsTriangle(It))return!0}}else{const l=n+8,p=c[n+6];return R(l,r,ee),!!(i.intersectsBox(ee)&&tn(l,t,e,s,i)||(R(p,r,ee),i.intersectsBox(ee)&&tn(p,t,e,s,i)))}}const se=new et,Ie=new V,qt=new V,Ti=new I,Si=new I,Pi=new I,Bi=new I;function _i(n,t,e,s={},i={},r=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Ie.set(t.boundingBox.min,t.boundingBox.max,e),Ie.needsUpdate=!0;const c=n.geometry,o=c.attributes.position,f=c.index,l=t.attributes.position,p=t.index,u=j.getPrimitive(),d=j.getPrimitive();let w=Ti,b=Si,x=null,h=null;i&&(x=Pi,h=Bi);let y=1/0,g=null,A=null;return se.copy(e).invert(),qt.matrix.copy(se),n.shapecast({boundsTraverseOrder:m=>Ie.distanceToBox(m),intersectsBounds:(m,T,S)=>S<y&&S<a?(T&&(qt.min.copy(m.min),qt.max.copy(m.max),qt.needsUpdate=!0),!0):!1,intersectsRange:(m,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>qt.distanceToBox(P),intersectsBounds:(P,B,v)=>v<y&&v<a,intersectsRange:(P,B)=>{for(let v=P,C=P+B;v<C;v++){D(d,3*v,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let _=m,M=m+T;_<M;_++){D(u,3*_,f,o),u.needsUpdate=!0;const E=u.distanceToTriangle(d,w,x);if(E<y&&(b.copy(w),h&&h.copy(x),y=E,g=_,A=v),E<r)return!0}}}});{const S=Ft(t);for(let P=0,B=S;P<B;P++){D(d,3*P,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=m,C=m+T;v<C;v++){D(u,3*v,f,o),u.needsUpdate=!0;const _=u.distanceToTriangle(d,w,x);if(_<y&&(b.copy(w),h&&h.copy(x),y=_,g=v,A=P),_<r)return!0}}}}}),j.releasePrimitive(u),j.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(b):s.point=b.clone(),s.distance=y,s.faceIndex=g,i&&(i.point?i.point.copy(h):i.point=h.clone(),i.point.applyMatrix4(se),b.applyMatrix4(se),i.distance=b.sub(i.point).length(),i.faceIndex=A),s)}function vi(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let r,a,c,o,f=0;const l=n._roots;for(let u=0,d=l.length;u<d;u++)r=l[u],a=new Uint32Array(r),c=new Uint16Array(r),o=new Float32Array(r),p(0,f),f+=r.byteLength;function p(u,d,w=!1){const b=u*2;if(c[b+15]===Te){const h=a[u+6],y=c[b+14];let g=1/0,A=1/0,m=1/0,T=-1/0,S=-1/0,P=-1/0;for(let B=h,v=h+y;B<v;B++){const C=3*n.resolveTriangleIndex(B);for(let _=0;_<3;_++){let M=C+_;M=s?s[M]:M;const E=i.getX(M),z=i.getY(M),L=i.getZ(M);E<g&&(g=E),E>T&&(T=E),z<A&&(A=z),z>S&&(S=z),L<m&&(m=L),L>P&&(P=L)}}return o[u+0]!==g||o[u+1]!==A||o[u+2]!==m||o[u+3]!==T||o[u+4]!==S||o[u+5]!==P?(o[u+0]=g,o[u+1]=A,o[u+2]=m,o[u+3]=T,o[u+4]=S,o[u+5]=P,!0):!1}else{const h=u+8,y=a[u+6],g=h+d,A=y+d;let m=w,T=!1,S=!1;t?m||(T=t.has(g),S=t.has(A),m=!T&&!S):(T=!0,S=!0);const P=m||T,B=m||S;let v=!1;P&&(v=p(h,d,m));let C=!1;B&&(C=p(y,d,m));const _=v||C;if(_)for(let M=0;M<3;M++){const E=h+M,z=y+M,L=o[E],U=o[E+3],_t=o[z],yt=o[z+3];o[u+M]=L<_t?L:_t,o[u+M+3]=U>yt?U:yt}return _}}}function Mi(n,t,e,s,i,r,a){N.setBuffer(n._roots[t]),en(0,n,e,s,i,r,a),N.clearBuffer()}function en(n,t,e,s,i,r,a){const{float32Array:c,uint16Array:o,uint32Array:f}=N,l=n*2;if($(l,o)){const u=G(n,f),d=O(l,o);yi(t,e,s,u,d,i,r,a)}else{const u=H(n);ht(u,c,s,r,a)&&en(u,t,e,s,i,r,a);const d=X(n,f);ht(d,c,s,r,a)&&en(d,t,e,s,i,r,a)}}const Ci=["x","y","z"];function Ii(n,t,e,s,i,r){N.setBuffer(n._roots[t]);const a=nn(0,n,e,s,i,r);return N.clearBuffer(),a}function nn(n,t,e,s,i,r){const{float32Array:a,uint16Array:c,uint32Array:o}=N;let f=n*2;if($(f,c)){const p=G(n,o),u=O(f,c);return mi(t,e,s,p,u,i,r)}else{const p=ts(n,o),u=Ci[p],w=s.direction[u]>=0;let b,x;w?(b=H(n),x=X(n,o)):(b=X(n,o),x=H(n));const y=ht(b,a,s,i,r)?nn(b,t,e,s,i,r):null;if(y){const m=y.point[u];if(w?m<=a[x+p]:m>=a[x+p+3])return y}const A=ht(x,a,s,i,r)?nn(x,t,e,s,i,r):null;return y&&A?y.distance<=A.distance?y:A:y||A||null}}const ie=new nt,Et=new Z,zt=new Z,$t=new et,vn=new V,re=new V;function Ei(n,t,e,s){N.setBuffer(n._roots[t]);const i=sn(0,n,e,s);return N.clearBuffer(),i}function sn(n,t,e,s,i=null){const{float32Array:r,uint16Array:a,uint32Array:c}=N;let o=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),vn.set(e.boundingBox.min,e.boundingBox.max,s),i=vn),$(o,a)){const l=t.geometry,p=l.index,u=l.attributes.position,d=e.index,w=e.attributes.position,b=G(n,c),x=O(o,a);if($t.copy(s).invert(),e.boundsTree)return R(n,r,re),re.matrix.copy($t),re.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:y=>re.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let g=b,A=x+b;g<A;g++)if(D(zt,3*t.resolveTriangleIndex(g),p,u),zt.needsUpdate=!0,y.intersectsTriangle(zt))return!0;return!1}});for(let h=b,y=x+b;h<y;h++){const g=t.resolveTriangleIndex(h);D(Et,3*g,p,u),Et.a.applyMatrix4($t),Et.b.applyMatrix4($t),Et.c.applyMatrix4($t),Et.needsUpdate=!0;for(let A=0,m=d.count;A<m;A+=3)if(D(zt,A,d,w),zt.needsUpdate=!0,Et.intersectsTriangle(zt))return!0}}else{const l=n+8,p=c[n+6];return R(l,r,ie),!!(i.intersectsBox(ie)&&sn(l,t,e,s,i)||(R(p,r,ie),i.intersectsBox(ie)&&sn(p,t,e,s,i)))}}const oe=new et,Ee=new V,Gt=new V,zi=new I,Li=new I,Ni=new I,Ri=new I;function Fi(n,t,e,s={},i={},r=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Ee.set(t.boundingBox.min,t.boundingBox.max,e),Ee.needsUpdate=!0;const c=n.geometry,o=c.attributes.position,f=c.index,l=t.attributes.position,p=t.index,u=j.getPrimitive(),d=j.getPrimitive();let w=zi,b=Li,x=null,h=null;i&&(x=Ni,h=Ri);let y=1/0,g=null,A=null;return oe.copy(e).invert(),Gt.matrix.copy(oe),n.shapecast({boundsTraverseOrder:m=>Ee.distanceToBox(m),intersectsBounds:(m,T,S)=>S<y&&S<a?(T&&(Gt.min.copy(m.min),Gt.max.copy(m.max),Gt.needsUpdate=!0),!0):!1,intersectsRange:(m,T)=>{if(t.boundsTree){const S=t.boundsTree;return S.shapecast({boundsTraverseOrder:P=>Gt.distanceToBox(P),intersectsBounds:(P,B,v)=>v<y&&v<a,intersectsRange:(P,B)=>{for(let v=P,C=P+B;v<C;v++){const _=S.resolveTriangleIndex(v);D(d,3*_,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let M=m,E=m+T;M<E;M++){const z=n.resolveTriangleIndex(M);D(u,3*z,f,o),u.needsUpdate=!0;const L=u.distanceToTriangle(d,w,x);if(L<y&&(b.copy(w),h&&h.copy(x),y=L,g=M,A=v),L<r)return!0}}}})}else{const S=Ft(t);for(let P=0,B=S;P<B;P++){D(d,3*P,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=m,C=m+T;v<C;v++){const _=n.resolveTriangleIndex(v);D(u,3*_,f,o),u.needsUpdate=!0;const M=u.distanceToTriangle(d,w,x);if(M<y&&(b.copy(w),h&&h.copy(x),y=M,g=v,A=P),M<r)return!0}}}}}),j.releasePrimitive(u),j.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(b):s.point=b.clone(),s.distance=y,s.faceIndex=g,i&&(i.point?i.point.copy(h):i.point=h.clone(),i.point.applyMatrix4(oe),b.applyMatrix4(oe),i.distance=b.sub(i.point).length(),i.faceIndex=A),s)}function Di(){return typeof SharedArrayBuffer<"u"}const Xt=new N.constructor,xe=new N.constructor,ut=new an(()=>new nt),Lt=new nt,Nt=new nt,ze=new nt,Le=new nt;let Ne=!1;function Ui(n,t,e,s){if(Ne)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ne=!0;const i=n._roots,r=t._roots;let a,c=0,o=0;const f=new et().copy(e).invert();for(let l=0,p=i.length;l<p;l++){Xt.setBuffer(i[l]),o=0;const u=ut.getPrimitive();R(0,Xt.float32Array,u),u.applyMatrix4(f);for(let d=0,w=r.length;d<w&&(xe.setBuffer(r[d]),a=J(0,0,e,f,s,c,o,0,0,u),xe.clearBuffer(),o+=r[d].length,!a);d++);if(ut.releasePrimitive(u),Xt.clearBuffer(),c+=i[l].length,a)break}return Ne=!1,a}function J(n,t,e,s,i,r=0,a=0,c=0,o=0,f=null,l=!1){let p,u;l?(p=xe,u=Xt):(p=Xt,u=xe);const d=p.float32Array,w=p.uint32Array,b=p.uint16Array,x=u.float32Array,h=u.uint32Array,y=u.uint16Array,g=n*2,A=t*2,m=$(g,b),T=$(A,y);let S=!1;if(T&&m)l?S=i(G(t,h),O(t*2,y),G(n,w),O(n*2,b),o,a+t,c,r+n):S=i(G(n,w),O(n*2,b),G(t,h),O(t*2,y),c,r+n,o,a+t);else if(T){const P=ut.getPrimitive();R(t,x,P),P.applyMatrix4(e);const B=H(n),v=X(n,w);R(B,d,Lt),R(v,d,Nt);const C=P.intersectsBox(Lt),_=P.intersectsBox(Nt);S=C&&J(t,B,s,e,i,a,r,o,c+1,P,!l)||_&&J(t,v,s,e,i,a,r,o,c+1,P,!l),ut.releasePrimitive(P)}else{const P=H(t),B=X(t,h);R(P,x,ze),R(B,x,Le);const v=f.intersectsBox(ze),C=f.intersectsBox(Le);if(v&&C)S=J(n,P,e,s,i,r,a,c,o+1,f,l)||J(n,B,e,s,i,r,a,c,o+1,f,l);else if(v)if(m)S=J(n,P,e,s,i,r,a,c,o+1,f,l);else{const _=ut.getPrimitive();_.copy(ze).applyMatrix4(e);const M=H(n),E=X(n,w);R(M,d,Lt),R(E,d,Nt);const z=_.intersectsBox(Lt),L=_.intersectsBox(Nt);S=z&&J(P,M,s,e,i,a,r,o,c+1,_,!l)||L&&J(P,E,s,e,i,a,r,o,c+1,_,!l),ut.releasePrimitive(_)}else if(C)if(m)S=J(n,B,e,s,i,r,a,c,o+1,f,l);else{const _=ut.getPrimitive();_.copy(Le).applyMatrix4(e);const M=H(n),E=X(n,w);R(M,d,Lt),R(E,d,Nt);const z=_.intersectsBox(Lt),L=_.intersectsBox(Nt);S=z&&J(B,M,s,e,i,a,r,o,c+1,_,!l)||L&&J(B,E,s,e,i,a,r,o,c+1,_,!l),ut.releasePrimitive(_)}}return S}const ce=new V,Mn=new nt,ki={strategy:Kn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class ln{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,r=t._indirectBuffer,a=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(o=>o.slice()),index:a?a.array.slice():null,indirectBuffer:r?r.slice():null}:c={roots:i,index:a?a.array:null,indirectBuffer:r},c}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:r,indirectBuffer:a}=t,c=new ln(e,{...s,[Be]:!0});if(c._roots=r,c._indirectBuffer=a||null,s.setIndex){const o=e.getIndex();if(o===null){const f=new be(t.index,1,!1);e.setIndex(f)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...ki,[Be]:!1},e),e.useSharedArrayBuffer&&!Di())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[Be]||(ti(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new nt))),this.resolveTriangleIndex=e.indirect?s=>this._indirectBuffer[s]:s=>s}refit(t=null){return(this.indirect?vi:hi)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);a(0);function a(c,o=0){const f=c*2,l=r[f+15]===Te;if(l){const p=i[c+6],u=r[f+14];t(o,l,new Float32Array(s,c*4,6),p,u)}else{const p=c+Ht/4,u=i[c+6],d=i[c+7];t(o,l,new Float32Array(s,c*4,6),d)||(a(p,o+1),a(u,o+1))}}}raycast(t,e=pn,s=0,i=1/0){const r=this._roots,a=this.geometry,c=[],o=e.isMaterial,f=Array.isArray(e),l=a.groups,p=o?e.side:e,u=this.indirect?Mi:xi;for(let d=0,w=r.length;d<w;d++){const b=f?e[l[d].materialIndex].side:p,x=c.length;if(u(this,d,b,t,c,s,i),f){const h=l[d].materialIndex;for(let y=x,g=c.length;y<g;y++)c[y].face.materialIndex=h}}return c}raycastFirst(t,e=pn,s=0,i=1/0){const r=this._roots,a=this.geometry,c=e.isMaterial,o=Array.isArray(e);let f=null;const l=a.groups,p=c?e.side:e,u=this.indirect?Ii:Ai;for(let d=0,w=r.length;d<w;d++){const b=o?e[l[d].materialIndex].side:p,x=u(this,d,b,t,s,i);x!=null&&(f==null||x.distance<f.distance)&&(f=x,o&&(x.face.materialIndex=l[d].materialIndex))}return f}intersectsGeometry(t,e){let s=!1;const i=this._roots,r=this.indirect?Ei:bi;for(let a=0,c=i.length;a<c&&(s=r(this,a,t,e),!s);a++);return s}shapecast(t){const e=j.getPrimitive(),s=this.indirect?gi:di;let{boundsTraverseOrder:i,intersectsBounds:r,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const p=a;a=(u,d,w,b,x)=>p(u,d,w,b,x)?!0:s(u,d,this,c,w,b,e)}else a||(c?a=(p,u,d,w)=>s(p,u,this,c,d,w,e):a=(p,u,d)=>d);let o=!1,f=0;const l=this._roots;for(let p=0,u=l.length;p<u;p++){const d=l[p];if(o=oi(this,p,r,a,i,f),o)break;f+=d.byteLength}return j.releasePrimitive(e),o}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const a=j.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,f=this.indirect?w=>{const b=this.resolveTriangleIndex(w);D(a,b*3,c,o)}:w=>{D(a,w*3,c,o)},l=j.getPrimitive(),p=t.geometry.index,u=t.geometry.attributes.position,d=t.indirect?w=>{const b=t.resolveTriangleIndex(w);D(l,b*3,p,u)}:w=>{D(l,w*3,p,u)};if(r){const w=(b,x,h,y,g,A,m,T)=>{for(let S=h,P=h+y;S<P;S++){d(S),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let B=b,v=b+x;B<v;B++)if(f(B),a.needsUpdate=!0,r(a,l,B,S,g,A,m,T))return!0}return!1};if(i){const b=i;i=function(x,h,y,g,A,m,T,S){return b(x,h,y,g,A,m,T,S)?!0:w(x,h,y,g,A,m,T,S)}}else i=w}return Ui(this,t,e,i)}intersectsBox(t,e){return ce.set(t.min,t.max,e),ce.needsUpdate=!0,this.shapecast({intersectsBounds:s=>ce.intersectsBox(s),intersectsTriangle:s=>ce.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,a=1/0){return(this.indirect?Fi:_i)(this,t,e,s,i,r,a)}closestPointToPoint(t,e={},s=0,i=1/0){return ci(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{R(0,new Float32Array(s),Mn),t.union(Mn)}),t}}const ss=1e-6,Vi=ss*.5,is=Math.pow(10,-Math.log10(ss)),qi=Vi*is;function tt(n){return~~(n*is+qi)}function $i(n){return`${tt(n.x)},${tt(n.y)}`}function Cn(n){return`${tt(n.x)},${tt(n.y)},${tt(n.z)}`}function Gi(n){return`${tt(n.x)},${tt(n.y)},${tt(n.z)},${tt(n.w)}`}function Wi(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}function rs(){return typeof SharedArrayBuffer<"u"}function Oi(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,s=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(s).set(i,0),new t(s)}function Hi(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Xi(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Hi(e,s);n.setIndex(new be(i,1));for(let r=0;r<e;r++)i[r]=r}}function ji(n){return n.index?n.index.count:n.attributes.position.count}function un(n){return ji(n)/3}const Yi=1e-8,Zi=new I;function Ki(n){return~~(n/3)}function Ji(n){return n%3}function In(n,t){return n.start-t.start}function En(n,t){return Zi.subVectors(t,n.origin).dot(n.direction)}function Qi(n,t,e,s=Yi){n.sort(In),t.sort(In);for(let c=0;c<n.length;c++){const o=n[c];for(let f=0;f<t.length;f++){const l=t[f];if(!(l.start>o.end)){if(o.end<l.start||l.end<o.start)continue;if(o.start<=l.start&&o.end>=l.end)r(l.end,o.end)||n.splice(c+1,0,{start:l.end,end:o.end,index:o.index}),o.end=l.start,l.start=0,l.end=0;else if(o.start>=l.start&&o.end<=l.end)r(o.end,l.end)||t.splice(f+1,0,{start:o.end,end:l.end,index:l.index}),l.end=o.start,o.start=0,o.end=0;else if(o.start<=l.start&&o.end<=l.end){const p=o.end;o.end=l.start,l.start=p}else if(o.start>=l.start&&o.end>=l.end){const p=l.end;l.end=o.start,o.start=p}else throw new Error}if(e.has(o.index)||e.set(o.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(o.index).push(l.index),e.get(l.index).push(o.index),a(l)&&(t.splice(f,1),f--),a(o)){n.splice(c,1),c--;break}}}i(n),i(t);function i(c){for(let o=0;o<c.length;o++)a(c[o])&&(c.splice(o,1),o--)}function r(c,o){return Math.abs(o-c)<s}function a(c){return Math.abs(c.end-c.start)<s}}const zn=1e-5,Ln=1e-4;class tr{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,r=null;for(let o=0,f=e.length;o<f;o++){const l=e[o];if(a(l,t)&&a(l,s))continue;const p=c(l,t),u=c(l,s),d=Math.min(p,u);d<i&&(i=d,r=l)}return r;function a(o,f){const l=o.origin.distanceTo(f.origin)>zn;return o.direction.angleTo(f.direction)>Ln||l}function c(o,f){const l=o.origin.distanceTo(f.origin),p=o.direction.angleTo(f.direction);return l/zn+p/Ln}}}const Re=new I,Fe=new I,ae=new Zn;function er(n,t,e){const s=n.attributes,i=n.index,r=s.position,a=new Map,c=new Map,o=Array.from(t),f=new tr;for(let l=0,p=o.length;l<p;l++){const u=o[l],d=Ki(u),w=Ji(u);let b=3*d+w,x=3*d+(w+1)%3;i&&(b=i.getX(b),x=i.getX(x)),Re.fromBufferAttribute(r,b),Fe.fromBufferAttribute(r,x),Wi(Re,Fe,ae);let h,y=f.findClosestRay(ae);y===null&&(y=ae.clone(),f.addRay(y)),c.has(y)||c.set(y,{forward:[],reverse:[],ray:y}),h=c.get(y);let g=En(y,Re),A=En(y,Fe);g>A&&([g,A]=[A,g]),ae.direction.dot(y.direction)<0?h.reverse.push({start:g,end:A,index:u}):h.forward.push({start:g,end:A,index:u})}return c.forEach(({forward:l,reverse:p},u)=>{Qi(l,p,a,e),l.length===0&&p.length===0&&c.delete(u)}),{disjointConnectivityMap:a,fragmentMap:c}}const nr=new Pt,De=new I,sr=new Bt,Ue=["","",""];class ir{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(r=>~~(r/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(r=>r%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:r}=this,a=e?g:y,c=new Map,{attributes:o}=t,f=e?Object.keys(o):null,l=t.index,p=o.position;let u=un(t);const d=u;let w=0;s&&(w=t.drawRange.start,t.drawRange.count!==1/0&&(u=~~(t.drawRange.count/3)));let b=this.data;(!b||b.length<3*d)&&(b=new Int32Array(3*d)),b.fill(-1);let x=0,h=new Set;for(let A=w,m=u*3+w;A<m;A+=3){const T=A;for(let S=0;S<3;S++){let P=T+S;l&&(P=l.getX(P)),Ue[S]=a(P)}for(let S=0;S<3;S++){const P=(S+1)%3,B=Ue[S],v=Ue[P],C=`${v}_${B}`;if(c.has(C)){const _=T+S,M=c.get(C);b[_]=M,b[M]=_,c.delete(C),x+=2,h.delete(M)}else{const _=`${B}_${v}`,M=T+S;c.set(_,M),h.add(M)}}}if(i){const{fragmentMap:A,disjointConnectivityMap:m}=er(t,h,r);h.clear(),A.forEach(({forward:T,reverse:S})=>{T.forEach(({index:P})=>h.add(P)),S.forEach(({index:P})=>h.add(P))}),this.unmatchedDisjointEdges=A,this.disjointConnections=m,x=u*3-h.size}this.matchedEdges=x,this.unmatchedEdges=h.size,this.data=b;function y(A){return De.fromBufferAttribute(p,A),Cn(De)}function g(A){let m="";for(let T=0,S=f.length;T<S;T++){const P=o[f[T]];let B;switch(P.itemSize){case 1:B=tt(P.getX(A));break;case 2:B=$i(nr.fromBufferAttribute(P,A));break;case 3:B=Cn(De.fromBufferAttribute(P,A));break;case 4:B=Gi(sr.fromBufferAttribute(P,A));break}m!==""&&(m+="|"),m+=B}return m}}}class we extends je{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new et,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let r=0;r<16;r++)if(s[r]!==i[r])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=rs();if(s)for(const i in e){const r=e[i];if(r.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");r.array=Oi(r.array)}if(t.boundsTree||(Xi(t,{useSharedArrayBuffer:s}),t.boundsTree=new ln(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new ir(t)),!t.groupIndices){const i=un(t),r=new Uint16Array(i),a=t.groups;for(let c=0,o=a.length;c<o;c++){const{start:f,count:l}=a[c];for(let p=f/3,u=(f+l)/3;p<u;p++)r[p]=c}t.groupIndices=r}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const rr=1e-14,ke=new I,Nn=new I,Rn=new I;function ft(n,t=rr){ke.subVectors(n.b,n.a),Nn.subVectors(n.c,n.a),Rn.subVectors(n.b,n.c);const e=ke.angleTo(Nn),s=ke.angleTo(Rn),i=Math.PI-e-s;return Math.abs(e)<t||Math.abs(s)<t||Math.abs(i)<t||n.a.distanceToSquared(n.b)<t||n.a.distanceToSquared(n.c)<t||n.b.distanceToSquared(n.c)<t}const Ve=1e-10,Wt=1e-10,or=1e-10,st=new Y,F=new Y,it=new I,qe=new I,Fn=new I,le=new rn,$e=new Z;class cr{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new q),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class ar{constructor(){this.trianglePool=new cr,this.triangles=[],this.normal=new I,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:s,normal:i}=this;if(Array.isArray(t))for(let r=0,a=t.length;r<a;r++){const c=t[r];if(r===0)c.getNormal(i);else if(Math.abs(1-c.getNormal(it).dot(i))>Ve)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const o=s.getTriangle();o.copy(c),e.push(o)}else{t.getNormal(i);const r=s.getTriangle();r.copy(t),e.push(r)}}splitByTriangle(t){const{normal:e,triangles:s}=this;if(t.getNormal(qe).normalize(),Math.abs(1-Math.abs(qe.dot(e)))<or){this.coplanarTriangleUsed=!0;for(let r=0,a=s.length;r<a;r++){const c=s[r];c.coplanarCount=0}const i=[t.a,t.b,t.c];for(let r=0;r<3;r++){const a=(r+1)%3,c=i[r],o=i[a];it.subVectors(o,c).normalize(),Fn.crossVectors(qe,it),le.setFromNormalAndCoplanarPoint(Fn,c),this.splitByPlane(le,t)}}else t.getPlane(le),this.splitByPlane(le,t)}splitByPlane(t,e){const{triangles:s,trianglePool:i}=this;$e.copy(e),$e.needsUpdate=!0;for(let r=0,a=s.length;r<a;r++){const c=s[r];if(!$e.intersectsTriangle(c,st,!0))continue;const{a:o,b:f,c:l}=c;let p=0,u=-1,d=!1,w=[],b=[];const x=[o,f,l];for(let h=0;h<3;h++){const y=(h+1)%3;st.start.copy(x[h]),st.end.copy(x[y]);const g=t.distanceToPoint(st.start),A=t.distanceToPoint(st.end);if(Math.abs(g)<Wt&&Math.abs(A)<Wt){d=!0;break}if(g>0?w.push(h):b.push(h),Math.abs(g)<Wt)continue;let m=!!t.intersectLine(st,it);!m&&Math.abs(A)<Wt&&(it.copy(st.end),m=!0),m&&!(it.distanceTo(st.start)<Ve)&&(it.distanceTo(st.end)<Ve&&(u=h),p===0?F.start.copy(it):F.end.copy(it),p++)}if(!d&&p===2&&F.distance()>Wt)if(u!==-1){u=(u+1)%3;let h=0;h===u&&(h=(h+1)%3);let y=h+1;y===u&&(y=(y+1)%3);const g=i.getTriangle();g.a.copy(x[y]),g.b.copy(F.end),g.c.copy(F.start),ft(g)||s.push(g),c.a.copy(x[h]),c.b.copy(F.start),c.c.copy(F.end),ft(c)&&(s.splice(r,1),r--,a--)}else{const h=w.length>=2?b[0]:w[0];if(h===0){let T=F.start;F.start=F.end,F.end=T}const y=(h+1)%3,g=(h+2)%3,A=i.getTriangle(),m=i.getTriangle();x[y].distanceToSquared(F.start)<x[g].distanceToSquared(F.end)?(A.a.copy(x[y]),A.b.copy(F.start),A.c.copy(F.end),m.a.copy(x[y]),m.b.copy(x[g]),m.c.copy(F.start)):(A.a.copy(x[g]),A.b.copy(F.start),A.c.copy(F.end),m.a.copy(x[y]),m.b.copy(x[g]),m.c.copy(F.end)),c.a.copy(x[h]),c.b.copy(F.end),c.c.copy(F.start),ft(A)||s.push(A),ft(m)||s.push(m),ft(c)&&(s.splice(r,1),r--,a--)}else p===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function lr(n){return n=~~n,n+4-n%4}class Dn{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,s=rs()?SharedArrayBuffer:ArrayBuffer,i=new e(new s(lr(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:s}=this;s+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,r=t.length;i<r;i++)e[s+i]=t[i];this.length+=t.length}clear(){this.length=0}}class ur{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:s}=this;let i=0;for(let r=0;r<e;r++){const a=s[r];i+=a[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const s=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const r in s){const a=s[r],c=new Dn(a.type);c.itemSize=a.itemSize,c.normalized=a.normalized,i[r]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:s}=this;if(!s[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,s,i){const{groupAttributes:r}=this,c=r[0][t];if(c){if(c.type!==e)for(let o=0,f=r.length;o<f;o++){const l=r[o][t];l.setType(e),l.itemSize=s,l.normalized=i}}else for(let o=0,f=r.length;o<f;o++){const l=new Dn(e);l.itemSize=s,l.normalized=i,r[o][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const s in e)e[s].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Un{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:s,ids:i}=this;s[t]||(s[t]=[],i.push(t)),s[t].push(e)}}const fr=0,os=1,pr=2,dr=3,hr=4,cs=5,as=6,W=new Zn,kn=new et,k=new q,rt=new I,Vn=new Bt,qn=new Bt,$n=new Bt,Ge=new Bt,ue=new Bt,fe=new Bt,Gn=new Y,We=new I,Oe=1e-8,yr=1e-15,bt=-1,Tt=1,ye=-2,me=2,jt=0,wt=1,fn=2,mr=1e-14;let ge=null;function Wn(n){ge=n}function ls(n,t){n.getMidpoint(W.origin),n.getNormal(W.direction);const e=t.raycastFirst(W,on);return!!(e&&W.direction.dot(e.face.normal)>0)?bt:Tt}function gr(n,t){function e(){return Math.random()-.5}n.getNormal(We),W.direction.copy(We),n.getMidpoint(W.origin);const s=3;let i=0,r=1/0;for(let a=0;a<s;a++){W.direction.x+=e()*Oe,W.direction.y+=e()*Oe,W.direction.z+=e()*Oe,W.direction.multiplyScalar(-1);const c=t.raycastFirst(W,on);if(!!(c&&W.direction.dot(c.face.normal)>0)&&i++,c!==null&&(r=Math.min(r,c.distance)),r<=yr)return c.face.normal.dot(We)>0?me:ye;if(i/s>.5||(a-i+1)/s>.5)break}return i/s>.5?bt:Tt}function xr(n,t){const e=new Un,s=new Un;return kn.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,kn,{intersectsTriangles(i,r,a,c){if(!ft(i)&&!ft(r)){let o=i.intersectsTriangle(r,Gn,!0);if(!o){const f=i.plane,l=r.plane,p=f.normal,u=l.normal;p.dot(u)===1&&Math.abs(f.constant-l.constant)<mr&&(o=!0)}if(o){let f=n.geometry.boundsTree.resolveTriangleIndex(a),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(f,l),s.add(l,f),ge&&(ge.addEdge(Gn),ge.addIntersectingTriangles(a,i,c,r))}}return!1}}),{aIntersections:e,bIntersections:s}}function wr(n,t,e,s,i,r,a=!1){const c=e.attributes,o=e.index,f=n*3,l=o.getX(f+0),p=o.getX(f+1),u=o.getX(f+2);for(const d in r){const w=c[d],b=r[d];if(!(d in c))throw new Error(`CSG Operations: Attribute ${d} not available on geometry.`);const x=w.itemSize;d==="position"?(k.a.fromBufferAttribute(w,l).applyMatrix4(s),k.b.fromBufferAttribute(w,p).applyMatrix4(s),k.c.fromBufferAttribute(w,u).applyMatrix4(s),He(k.a,k.b,k.c,t,3,b,a)):d==="normal"?(k.a.fromBufferAttribute(w,l).applyNormalMatrix(i),k.b.fromBufferAttribute(w,p).applyNormalMatrix(i),k.c.fromBufferAttribute(w,u).applyNormalMatrix(i),a&&(k.a.multiplyScalar(-1),k.b.multiplyScalar(-1),k.c.multiplyScalar(-1)),He(k.a,k.b,k.c,t,3,b,a,!0)):(Vn.fromBufferAttribute(w,l),qn.fromBufferAttribute(w,p),$n.fromBufferAttribute(w,u),He(Vn,qn,$n,t,x,b,a))}}function Ar(n,t,e,s,i,r,a,c=!1){Xe(n,s,i,r,a,c),Xe(c?e:t,s,i,r,a,c),Xe(c?t:e,s,i,r,a,c)}function us(n,t,e=!1){switch(n){case fr:if(t===Tt||t===me&&!e)return wt;break;case os:if(e){if(t===bt)return jt}else if(t===Tt||t===ye)return wt;break;case pr:if(e){if(t===Tt||t===ye)return wt}else if(t===bt)return jt;break;case hr:if(t===bt)return jt;if(t===Tt)return wt;break;case dr:if(t===bt||t===me&&!e)return wt;break;case cs:if(!e&&(t===Tt||t===ye))return wt;break;case as:if(!e&&(t===bt||t===me))return wt;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return fn}function He(n,t,e,s,i,r,a=!1,c=!1){const o=f=>{r.push(f.x),i>1&&r.push(f.y),i>2&&r.push(f.z),i>3&&r.push(f.w)};Ge.set(0,0,0,0).addScaledVector(n,s.a.x).addScaledVector(t,s.a.y).addScaledVector(e,s.a.z),ue.set(0,0,0,0).addScaledVector(n,s.b.x).addScaledVector(t,s.b.y).addScaledVector(e,s.b.z),fe.set(0,0,0,0).addScaledVector(n,s.c.x).addScaledVector(t,s.c.y).addScaledVector(e,s.c.z),c&&(Ge.normalize(),ue.normalize(),fe.normalize()),o(Ge),a?(o(fe),o(ue)):(o(ue),o(fe))}function Xe(n,t,e,s,i,r=!1){for(const a in i){const c=t[a],o=i[a];if(!(a in t))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const f=c.itemSize;a==="position"?(rt.fromBufferAttribute(c,n).applyMatrix4(e),o.push(rt.x,rt.y,rt.z)):a==="normal"?(rt.fromBufferAttribute(c,n).applyNormalMatrix(s),r&&rt.multiplyScalar(-1),o.push(rt.x,rt.y,rt.z)):(o.push(c.getX(n)),f>1&&o.push(c.getY(n)),f>2&&o.push(c.getZ(n)),f>3&&o.push(c.getW(n)))}}class br{constructor(t){this.triangle=new q().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new q().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const s in e)t.push(e[s]);return t}}class On{constructor(){this.data={}}addTriangleIntersection(t,e,s,i){const{data:r}=this;r[t]||(r[t]=new br(e)),r[t].addTriangle(s,i)}getTrianglesAsArray(t=null){const{data:e}=this,s=[];if(t!==null)t in e&&s.push(e[t].triangle);else for(const i in e)s.push(e[i].triangle);return s}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(s=>parseInt(s)):[]}getIntersectionsAsArray(t=null,e=null){const{data:s}=this,i=new Set,r=[],a=c=>{if(s[c])if(e!==null)s[c].intersects[e]&&r.push(s[c].intersects[e]);else{const o=s[c].intersects;for(const f in o)i.has(f)||(i.add(f),r.push(o[f]))}};if(t!==null)a(t);else for(const c in s)a(c);return r}reset(){this.data={}}}class Tr{constructor(){this.enabled=!1,this.triangleIntersectsA=new On,this.triangleIntersectsB=new On,this.intersectionEdges=[]}addIntersectingTriangles(t,e,s,i){const{triangleIntersectsA:r,triangleIntersectsB:a}=this;r.addTriangleIntersection(t,e,s,i),a.addTriangleIntersection(s,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Wn(this))}complete(){this.enabled&&Wn(null)}}const dt=new et,Ae=new hs,At=new q,pe=new q,lt=new q,de=new q,Q=[],St=[];function Sr(n){for(const t of n)return t}function Pr(n,t,e,s,i,r={}){const{useGroups:a=!0}=r,{aIntersections:c,bIntersections:o}=xr(n,t),f=[];let l=null,p;return p=a?0:-1,Hn(n,t,c,e,!1,s,i,p),Xn(n,t,c,e,!1,i,p),e.findIndex(d=>d!==as&&d!==cs)!==-1&&(p=a?n.geometry.groups.length||1:-1,Hn(t,n,o,e,!0,s,i,p),Xn(t,n,o,e,!0,i,p)),Q.length=0,St.length=0,{groups:f,materials:l}}function Hn(n,t,e,s,i,r,a,c=0){const o=n.matrixWorld.determinant()<0;dt.copy(t.matrixWorld).invert().multiply(n.matrixWorld),Ae.getNormalMatrix(n.matrixWorld).multiplyScalar(o?-1:1);const f=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes.position,u=t.geometry.boundsTree,d=t.geometry.index,w=t.geometry.attributes.position,b=e.ids,x=e.intersectionSet;for(let h=0,y=b.length;h<y;h++){const g=b[h],A=c===-1?0:f[g]+c,m=3*g,T=l.getX(m+0),S=l.getX(m+1),P=l.getX(m+2);At.a.fromBufferAttribute(p,T).applyMatrix4(dt),At.b.fromBufferAttribute(p,S).applyMatrix4(dt),At.c.fromBufferAttribute(p,P).applyMatrix4(dt),r.reset(),r.initialize(At);const B=x[g];for(let C=0,_=B.length;C<_;C++){const M=3*B[C],E=d.getX(M+0),z=d.getX(M+1),L=d.getX(M+2);pe.a.fromBufferAttribute(w,E),pe.b.fromBufferAttribute(w,z),pe.c.fromBufferAttribute(w,L),r.splitByTriangle(pe)}const v=r.triangles;for(let C=0,_=v.length;C<_;C++){const M=v[C],E=r.coplanarTriangleUsed?gr(M,u):ls(M,u);Q.length=0,St.length=0;for(let z=0,L=s.length;z<L;z++){const U=us(s[z],E,i);U!==fn&&(St.push(U),Q.push(a[z].getGroupAttrSet(A)))}if(Q.length!==0){At.getBarycoord(M.a,de.a),At.getBarycoord(M.b,de.b),At.getBarycoord(M.c,de.c);for(let z=0,L=Q.length;z<L;z++){const U=Q[z],yt=St[z]===jt;wr(g,de,n.geometry,n.matrixWorld,Ae,U,o!==yt)}}}}return b.length}function Xn(n,t,e,s,i,r,a=0){const c=n.matrixWorld.determinant()<0;dt.copy(t.matrixWorld).invert().multiply(n.matrixWorld),Ae.getNormalMatrix(n.matrixWorld).multiplyScalar(c?-1:1);const o=t.geometry.boundsTree,f=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes,u=p.position,d=[],w=n.geometry.halfEdges,b=new Set,x=un(n.geometry);for(let h=0,y=x;h<y;h++)h in e.intersectionSet||b.add(h);for(;b.size>0;){const h=Sr(b);b.delete(h),d.push(h);const y=3*h,g=l.getX(y+0),A=l.getX(y+1),m=l.getX(y+2);lt.a.fromBufferAttribute(u,g).applyMatrix4(dt),lt.b.fromBufferAttribute(u,A).applyMatrix4(dt),lt.c.fromBufferAttribute(u,m).applyMatrix4(dt);const T=ls(lt,o);St.length=0,Q.length=0;for(let S=0,P=s.length;S<P;S++){const B=us(s[S],T,i);B!==fn&&(St.push(B),Q.push(r[S]))}for(;d.length>0;){const S=d.pop();for(let P=0;P<3;P++){const B=w.getSiblingTriangleIndex(S,P);B!==-1&&b.has(B)&&(d.push(B),b.delete(B))}if(Q.length!==0){const P=3*S,B=l.getX(P+0),v=l.getX(P+1),C=l.getX(P+2),_=a===-1?0:f[S]+a;if(lt.a.fromBufferAttribute(u,B),lt.b.fromBufferAttribute(u,v),lt.c.fromBufferAttribute(u,C),!ft(lt))for(let M=0,E=Q.length;M<E;M++){const z=St[M],L=Q[M].getGroupAttrSet(_),U=z===jt;Ar(B,v,C,p,n.matrixWorld,Ae,L,U!==c)}}}}}function Br(n){for(let t=0;t<n.length-1;t++){const e=n[t],s=n[t+1];if(e.materialIndex===s.materialIndex){const i=e.start,r=s.start+s.count;s.start=i,s.count=r-i,n.splice(t,1),t--}}}function _r(n,t,e,s){e.clear();const i=n.attributes;for(let r=0,a=s.length;r<a;r++){const c=s[r],o=i[c];e.initializeArray(c,o.array.constructor,o.itemSize,o.normalized)}for(const r in e.attributes)s.includes(r)||e.delete(r);for(const r in t.attributes)s.includes(r)||(t.deleteAttribute(r),t.dispose())}function vr(n,t,e){let s=!1,i=-1;const r=n.attributes,a=t.groupAttributes[0];for(const o in a){const f=t.getTotalLength(o),l=t.getType(o),p=t.getItemSize(o),u=t.getNormalized(o);let d=r[o];(!d||d.array.length<f)&&(d=new be(new l(f),p,u),n.setAttribute(o,d),s=!0);let w=0;for(let b=0,x=Math.min(e.length,t.groupCount);b<x;b++){const h=e[b].index,{array:y,type:g,length:A}=t.groupAttributes[h][o],m=new g(y.buffer,0,A);d.array.set(m,w),w+=m.length}d.needsUpdate=!0,i=f/d.itemSize}if(n.index){const o=n.index.array;if(o.length<i)n.index=null,s=!0;else for(let f=0,l=o.length;f<l;f++)o[f]=f}let c=0;n.clearGroups();for(let o=0,f=Math.min(e.length,t.groupCount);o<f;o++){const{index:l,materialIndex:p}=e[o],u=t.getCount(l);u!==0&&(n.addGroup(c,u,p),c+=u)}n.setDrawRange(0,i),n.boundsTree=null,s&&n.dispose()}function jn(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(s=>{e[s.materialIndex]=t})),e}class Mr{constructor(){this.triangleSplitter=new ar,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new Tr}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,s,i=new we){let r=!0;if(Array.isArray(s)||(s=[s]),Array.isArray(i)||(i=[i],r=!1),i.length!==s.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:a,attributeData:c,attributes:o,useGroups:f,consolidateGroups:l,debug:p}=this;for(;c.length<i.length;)c.push(new ur);i.forEach((h,y)=>{_r(t.geometry,h.geometry,c[y],o)}),p.init(),Pr(t,e,s,a,c,{useGroups:f}),p.complete();const u=this.getGroupRanges(t.geometry),d=jn(u,t.material),w=this.getGroupRanges(e.geometry),b=jn(w,e.material);w.forEach(h=>h.materialIndex+=d.length);let x=[...u,...w].map((h,y)=>({...h,index:y}));if(f){const h=[...d,...b];l&&(x=x.map(g=>{const A=h[g.materialIndex];return g.materialIndex=h.indexOf(A),g}).sort((g,A)=>g.materialIndex-A.materialIndex));const y=[];for(let g=0,A=h.length;g<A;g++){let m=!1;for(let T=0,S=x.length;T<S;T++){const P=x[T];P.materialIndex===g&&(m=!0,P.materialIndex=y.length)}m&&y.push(h[g])}i.forEach(g=>{g.material=y})}else x=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(h=>{h.material=d[0]});return i.forEach((h,y)=>{const g=h.geometry;vr(g,c[y],x),l&&Br(g.groups)}),r?i:i[0]}evaluateHierarchy(t,e=new we){t.updateMatrixWorld(!0);const s=(r,a)=>{const c=r.children;for(let o=0,f=c.length;o<f;o++){const l=c[o];l.isOperationGroup?s(l,a):a(l)}},i=r=>{const a=r.children;let c=!1;for(let f=0,l=a.length;f<l;f++){const p=a[f];c=i(p)||c}const o=r.isDirty();if(o&&r.markUpdated(),c&&!r.isOperationGroup){let f;return s(r,l=>{f?f=this.evaluate(f,l,l.operation):f=this.evaluate(r,l,l.operation)}),r._cachedGeometry=f.geometry,r._cachedMaterials=f.material,!0}else return c||o};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}var Yn=`uniform float uTime;
uniform float uPositionFrequency;
uniform float uStrength;
uniform float uWarpFrequency;
uniform float uWarpStrength;

varying vec3 vPosition;
varying float vUpDot;

vec3 permute(vec3 x) {
    return mod(((x * 44.0) + 1.0) * x, 299.0);
}

float simplexNoise2d(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 299.0);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m * m;
    m = m * m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float getElevation(vec2 position) {
    vec2 warpedPosition = position;
    warpedPosition += uTime * 0.2;
    warpedPosition += simplexNoise2d(warpedPosition * uPositionFrequency * uWarpFrequency) * uWarpStrength;

    float elevation = 0.0;
    elevation += simplexNoise2d(warpedPosition * uPositionFrequency) / 2.0;
    elevation += simplexNoise2d(warpedPosition * uPositionFrequency * 2.0) / 4.0;
    elevation += simplexNoise2d(warpedPosition * uPositionFrequency * 4.0) / 8.0;

    float elevationSign = sign(elevation);
    elevation = pow(abs(elevation), 2.0) * elevationSign;
    elevation *= uStrength;

    return elevation;
}

void main() {
    
    float shift = 0.01;
    vec3 positionA = position.xyz + vec3(shift, 0.0, 0.0);
    vec3 positionB = position.xyz + vec3(0.0, 0.0, -shift);

    
    float elevation = getElevation(csm_Position.xz);
    csm_Position.y += elevation;
    positionA.y += getElevation(positionA.xz);
    positionB.y += getElevation(positionB.xz);

    
    vec3 toA = normalize(positionA - csm_Position);
    vec3 toB = normalize(positionB - csm_Position);
    csm_Normal = cross(toA, toB);

    
    vPosition = csm_Position;
    vPosition.xz += uTime * 0.2;
    vUpDot = dot(csm_Normal, vec3(0.0, 1.0, 0.0));
}`,Cr=`uniform vec3 uColorWaterDeep;
uniform vec3 uColorWaterSurface;
uniform vec3 uColorSand;
uniform vec3 uColorGrass;
uniform vec3 uColorSnow;
uniform vec3 uColorRock;

varying vec3 vPosition;
varying float vUpDot;

vec3 permute(vec3 x) {
    return mod(((x * 44.0) + 1.0) * x, 299.0);
}

float simplexNoise2d(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
    vec2 i = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 299.0);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
    m = m * m;
    m = m * m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
    vec3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

void main() {
    
    vec3 color = vec3(1.0);

    
    float surfaceWaterMix = smoothstep(-1.0, -0.1, vPosition.y);
    color = mix(uColorWaterDeep, uColorWaterSurface, surfaceWaterMix);

    
    float sandMix = step(-0.1, vPosition.y);
    color = mix(color, uColorSand, sandMix);

    
    float grassMix = step(-0.06, vPosition.y);
    color = mix(color, uColorGrass, grassMix);

    
    float rockMix = vUpDot;
    rockMix = 1.0 - step(0.8, rockMix);
    rockMix *= step(-0.06, vPosition.y);
    color = mix(color, uColorRock, rockMix);

    
    float snowThreshold = 0.45;
    snowThreshold += simplexNoise2d(vPosition.xz * 15.0) * 0.1;
    float snowMix = step(snowThreshold, vPosition.y);
    color = mix(color, uColorSnow, snowMix);

    
    csm_DiffuseColor = vec4(color, 1.0);
}`;const Ir=Cs({__name:"index",setup(n){new ys,new ms;const t=new Ms;let e,s,i,r,a,c,o,f;function l(){({container:e,renderer:s,scene:i,camera:r,clock:a,viewPort:c,tick:o}=bs(document.querySelector(".webgl")))}function p(){r.position.set(-10,6,-2),s.shadowMap.enabled=!0,s.shadowMap.type=Ts,s.toneMapping=Ss,s.toneMappingExposure=1,t.load("/texture/hdr/spruit_sunrise.hdr",T=>{T.mapping=Ps,i.background=T,i.backgroundBlurriness=.5,i.environment=T});const m=new Bs("#ffffff",2);m.position.set(6.25,3,4),m.castShadow=!0,m.shadow.mapSize.set(1024,1024),m.shadow.camera.near=.1,m.shadow.camera.far=30,m.shadow.camera.top=8,m.shadow.camera.right=8,m.shadow.camera.bottom=-8,m.shadow.camera.left=-8,i.add(m)}function u(){f=new _s(r,s.domElement),f.enableDamping=!0}function d(){Ls(c,()=>{const{width:m,height:T}=c.value;r.aspect=m/T,r.updateProjectionMatrix(),s.setSize(m,T,!1)})}let w,b={colorWaterDeep:"#002b3d",colorWaterSurface:"#66a8ff",colorSand:"#ffe894",colorGrass:"#85d534",colorSnow:"#ffffff",colorRock:"#bfbd8d"};function x(){w=new vs({container:document.querySelector(".debug")}),Ns(()=>w.destroy)}const h={uTime:new K(0),uPositionFrequency:new K(.2),uStrength:new K(2),uWarpFrequency:new K(5),uWarpStrength:new K(.5),uColorWaterDeep:new K(new vt(b.colorWaterDeep)),uColorWaterSurface:new K(new vt(b.colorWaterSurface)),uColorSand:new K(new vt(b.colorSand)),uColorGrass:new K(new vt(b.colorGrass)),uColorSnow:new K(new vt(b.colorSnow)),uColorRock:new K(new vt(b.colorRock))};Is(()=>{l(),x(),u(),d(),p(),y(),g(),A(),o(()=>{const m=a.getElapsedTime();h.uTime.value=m,f.update(),s.render(i,r)})});function y(){const m=new we(new dn(11,2,11)),T=new we(new dn(10,2.1,10)),P=new Mr().evaluate(m,T,os);P.geometry.clearGroups(),P.material=new hn({color:"#ffffff",metalness:0,roughness:.3}),P.castShadow=!0,P.receiveShadow=!0,i.add(P)}function g(){const m=new yn(10,10,500,500);m.deleteAttribute("uv"),m.deleteAttribute("normal"),m.rotateX(-Math.PI*.5),w.add(h.uPositionFrequency,"value",0,1,.001).name("uPositionFrequency"),w.add(h.uStrength,"value",0,10,.001).name("uStrength"),w.add(h.uWarpFrequency,"value",0,10,.001).name("uWarpFrequency"),w.add(h.uWarpStrength,"value",0,1,.001).name("uWarpStrength"),w.addColor(b,"colorWaterDeep").onChange(()=>h.uColorWaterDeep.value.set(b.colorWaterDeep)),w.addColor(b,"colorWaterSurface").onChange(()=>h.uColorWaterSurface.value.set(b.colorWaterSurface)),w.addColor(b,"colorSand").onChange(()=>h.uColorSand.value.set(b.colorSand)),w.addColor(b,"colorGrass").onChange(()=>h.uColorGrass.value.set(b.colorGrass)),w.addColor(b,"colorSnow").onChange(()=>h.uColorSnow.value.set(b.colorSnow)),w.addColor(b,"colorRock").onChange(()=>h.uColorRock.value.set(b.colorRock));const T=new mn({baseMaterial:hn,vertexShader:Yn,fragmentShader:Cr,uniforms:h,metalness:0,roughness:.5,color:"#85d534"}),S=new mn({baseMaterial:gs,vertexShader:Yn,uniforms:h,depthPacking:xs}),P=new je(m,T);P.customDepthMaterial=S,P.receiveShadow=!0,P.castShadow=!0,i.add(P)}function A(){const m=new je(new yn(10,10,1,1),new ws({transmission:1,roughness:.3}));m.rotation.x=-Math.PI*.5,m.position.y=-.1,i.add(m)}return(m,T)=>(Rs(),Es(As,null,{default:zs(()=>T[0]||(T[0]=[gn("div",{class:"webgl"},null,-1),gn("div",{class:"debug"},null,-1)])),_:1}))}}),Rr=Fs(Ir,[["__scopeId","data-v-3a3918ac"]]);export{Rr as default};
